# FASE 4: Generaci√≥n de Features de Contenido

## ‚úÖ Estado: COMPLETADA

## üìã Objetivo

Construir vectores de features de contenido para cada pel√≠cula combinando:
- **G√©neros**: One-hot encoding (sparse vectors) de los 19 g√©neros √∫nicos
- **Genome Tags**: Dense vectors con los top-50 tags m√°s relevantes del MovieLens Genome
- **Dimensionalidad total**: 69 features por pel√≠cula (19 g√©neros + 50 tags)

Estas features permitir√°n implementar un sistema h√≠brido que combine:
- **Collaborative filtering** (ALS) basado en ratings
- **Content-based filtering** basado en caracter√≠sticas de las pel√≠culas

---

## üìÇ Estructura de Salida

```
hdfs://namenode:9000/data/content_features/
‚îú‚îÄ‚îÄ movies_features/      1.7 MB   (27,278 pel√≠culas con vectores)
‚îú‚îÄ‚îÄ genres_metadata/      1.0 KB   (19 g√©neros indexados)
‚îî‚îÄ‚îÄ tags_metadata/        3.1 KB   (top-50 tags con avg_relevance)
```

**Total**: ~1.7 MB de features vectorizadas

---

## üîß Arquitectura de Features

### 1. **GENRES FEATURES** (Sparse One-Hot Encoding)

```python
Schema:
‚îú‚îÄ‚îÄ movieId: int
‚îú‚îÄ‚îÄ genres_vec: SparseVector(19)    # One-hot de g√©neros presentes
‚îî‚îÄ‚îÄ n_genres: int                    # Cantidad de g√©neros (1-6)
```

**19 g√©neros √∫nicos indexados**:
```
idx | genre        | idx | genre      | idx | genre
----|--------------|-----|------------|-----|----------
 0  | Action       |  7  | Drama      | 14  | Romance
 1  | Adventure    |  8  | Fantasy    | 15  | Sci-Fi
 2  | Animation    |  9  | Film-Noir  | 16  | Thriller
 3  | Children     | 10  | Horror     | 17  | War
 4  | Comedy       | 11  | IMAX       | 18  | Western
 5  | Crime        | 12  | Musical    |
 6  | Documentary  | 13  | Mystery    |
```

**Ejemplo**: "The Matrix (1999)" con g√©neros `["Action", "Sci-Fi", "Thriller"]`
```python
genres_vec = SparseVector(19, {0: 1.0, 15: 1.0, 16: 1.0})
#                           ‚Üë           ‚Üë            ‚Üë
#                        Action      Sci-Fi      Thriller
n_genres = 3
```

**Procesamiento**:
- Explosi√≥n de `genres_array` de movies.parquet
- Creaci√≥n de diccionario `genre_to_idx` con 19 g√©neros
- Broadcast del diccionario para UDF eficiente
- Generaci√≥n de `SparseVector` con √≠ndices de g√©neros presentes
- Pel√≠culas con `genres_array = []` ‚Üí vector vac√≠o (todos ceros)

**Estad√≠sticas**:
- **Promedio**: 1.99 g√©neros por pel√≠cula
- **Rango**: 0-6 g√©neros
- **Sparsity**: ~89.5% (solo 10.5% de valores = 1)

---

### 2. **GENOME TAGS FEATURES** (Dense Vectors)

```python
Schema:
‚îú‚îÄ‚îÄ movieId: int
‚îú‚îÄ‚îÄ tags_vec: DenseVector(50)       # Relevance scores top-50 tags
‚îú‚îÄ‚îÄ n_tags: int                      # Cantidad de tags con relevance >= 0.3
‚îî‚îÄ‚îÄ avg_tag_relevance: double        # Promedio de relevance (0.0-1.0)
```

**Pipeline de generaci√≥n**:

#### 2.1. Identificaci√≥n de Top-50 Tags
```python
# De 1,128 genome tags ‚Üí seleccionar los 50 con mayor avg_relevance
genome_scores.groupBy("tagId")
             .agg(F.avg("relevance").alias("avg_relevance"))
             .orderBy(F.desc("avg_relevance"))
             .limit(50)
```

**Top 10 tags seleccionados**:
| tagId | Tag              | Avg Relevance | N¬∞ Movies |
|-------|------------------|---------------|-----------|
| 742   | original         | 0.731         | 10,381    |
| 646   | mentor           | 0.530         | 10,381    |
| 468   | great ending     | 0.500         | 10,381    |
| 302   | dialogue         | 0.491         | 10,381    |
| 452   | good soundtrack  | 0.456         | 10,381    |
| 188   | catastrophe      | 0.451         | 10,381    |
| 972   | storytelling     | 0.448         | 10,381    |
| 971   | story            | 0.427         | 10,381    |
| 464   | great            | 0.427         | 10,381    |
| 445   | good             | 0.425         | 10,381    |

#### 2.2. Filtrado por Relevancia
```python
MIN_RELEVANCE = 0.3  # Umbral de relevancia m√≠nima

# De 11,709,768 genome scores ‚Üí 519,050 con top-50 tags
# Filtrado por MIN_RELEVANCE ‚Üí 292,984 scores finales
genome_scores.filter(
    (F.col("tagId").isin(top_50_tag_ids)) & 
    (F.col("relevance") >= MIN_RELEVANCE)
)
```

**Reducci√≥n**: 519K ‚Üí 293K scores (44% de datos eliminados por bajo relevance)

#### 2.3. Construcci√≥n de Dense Vectors
```python
# Para cada pel√≠cula, crear vector de 50 dimensiones
import numpy as np

def build_tag_vector(tag_scores, tag_idx_map):
    """
    tag_scores: [(tagId, relevance), ...]
    tag_idx_map: {tagId: idx} para top-50 tags
    """
    vector = np.zeros(50, dtype=float)
    for tag_id, relevance in tag_scores:
        if tag_id in tag_idx_map:
            idx = tag_idx_map[tag_id]
            vector[idx] = relevance
    return Vectors.dense(vector.tolist())
```

**Ejemplo**: "Slumdog Millionaire (2008)" - pel√≠cula con m√°s tags
```python
tags_vec = DenseVector([0.891, 0.0, 0.745, ..., 0.621])  # 50 valores
n_tags = 50                  # Tiene los 50 tags con relevance >= 0.3
avg_tag_relevance = 0.638
```

**Estad√≠sticas de Tags**:
- **Promedio**: 10.74 tags por pel√≠cula (relevance >= 0.3)
- **Pel√≠culas sin tags**: 16,897 (62%) - vector de ceros
- **Pel√≠culas con 50 tags**: 2 (Slumdog Millionaire, Life Itself)
- **Promedio de relevance**: 0.188 (considerando ceros)

**Distribuci√≥n de n_tags**:
```
n_tags | Pel√≠culas
-------|----------
   0   |  16,897  (62.0%) ‚Üí Depender√°n solo de g√©neros + CF
  1-5  |   1,289  (4.7%)
  6-10 |   1,873  (6.9%)
 11-15 |   2,024  (7.4%)
 16-20 |   1,889  (6.9%)
 21-25 |   1,534  (5.6%)
 26-30 |   1,038  (3.8%)
  31+  |     734  (2.7%)
```

---

### 3. **FEATURES COMBINADAS**

```python
Schema final de movies_features:
‚îú‚îÄ‚îÄ movieId: int
‚îú‚îÄ‚îÄ title: string
‚îú‚îÄ‚îÄ genres: string                   # Original pipe-separated
‚îú‚îÄ‚îÄ genres_vec: SparseVector(19)     # One-hot g√©neros
‚îú‚îÄ‚îÄ tags_vec: DenseVector(50)        # Relevance scores top-50 tags
‚îú‚îÄ‚îÄ n_genres: int
‚îú‚îÄ‚îÄ n_tags: int
‚îî‚îÄ‚îÄ avg_tag_relevance: double
```

**Ejemplo de pel√≠cula completa**:
```python
movieId: 293
title: "L√©on: The Professional (1994)"
genres: "Action|Crime|Drama|Thriller"
genres_vec: SparseVector(19, {0: 1.0, 5: 1.0, 7: 1.0, 16: 1.0})
tags_vec: DenseVector([0.812, 0.0, 0.623, ..., 0.751])  # 50 dims
n_genres: 4
n_tags: 49
avg_tag_relevance: 0.605
```

**Vector completo para ML**: Concatenar `genres_vec` (19) + `tags_vec` (50) = **69 features**

---

## üìä M√©tricas de Calidad

### Cobertura de Features
- **27,278 pel√≠culas** procesadas (100% del cat√°logo)
- **0 nulos** en movieId, genres_vec, tags_vec
- **10,381 pel√≠culas** con genome tags (38%)
- **16,897 pel√≠culas** sin genome tags (62%)

### Dimensionalidad
- **Genres**: 19 dimensiones (sparse, ~10.5% densidad)
- **Tags**: 50 dimensiones (dense, ~21.5% densidad considerando ceros)
- **Total**: 69 dimensiones por pel√≠cula

### Sparsity General
- **Pel√≠culas con features completas** (g√©neros + tags): 10,381 (38%)
- **Pel√≠culas solo con g√©neros**: 16,897 (62%)
- **Promedio de features no-cero**: ~13.73 por pel√≠cula

### Top Pel√≠culas por Features
**Pel√≠culas con m√°s genome tags**:
1. Slumdog Millionaire (2008): 50 tags, 0.638 avg relevance
2. Life Itself (2014): 50 tags, 0.660 avg relevance
3. The Prestige (2006): 49 tags, 0.693 avg relevance
4. L√©on: The Professional (1994): 49 tags, 0.605 avg relevance
5. Run Lola Run (1998): 49 tags, 0.660 avg relevance

---

## üõ†Ô∏è Implementaci√≥n T√©cnica

### Script Principal
**Archivo**: `movies/src/features/build_features.py` (580 l√≠neas)

**Pipeline completo**:
```python
def main():
    # 1. Cargar datos
    movies, genome_tags, genome_scores = load_data(spark)
    
    # 2. Identificar top-50 tags por avg_relevance
    top_tags = identify_top_tags(genome_scores, genome_tags, TOP_N_TAGS=50)
    
    # 3. Construir genres features (one-hot sparse)
    movies_with_genres = build_genres_features(movies, spark)
    
    # 4. Construir tags features (dense top-50)
    movies_features = build_tags_features(
        movies_with_genres, 
        genome_scores, 
        top_tags,
        MIN_RELEVANCE=0.3
    )
    
    # 5. Guardar a HDFS con metadata
    save_features(movies_features, genre_list, top_tags, spark)
    
    # 6. Validar output
    validate_features(movies_features)
```

### Configuraci√≥n Optimizada
```python
# Par√°metros de features
TOP_N_TAGS = 50              # Top tags por avg_relevance
MIN_RELEVANCE = 0.3          # Umbral de relevancia m√≠nima

# Spark optimizations
spark.conf.set("spark.sql.shuffle.partitions", "200")
spark.conf.set("spark.sql.adaptive.enabled", "true")
```

### UDFs Cr√≠ticos
```python
@F.udf(VectorUDT())
def genres_to_sparse_vector(genres_array):
    """Convierte array de g√©neros a SparseVector one-hot"""
    if not genres_array:
        return Vectors.sparse(19, {})
    
    indices = [genre_to_idx_bc.value.get(g) 
               for g in genres_array 
               if g in genre_to_idx_bc.value]
    values = [1.0] * len(indices)
    return Vectors.sparse(19, indices, values)

@F.udf(VectorUDT())
def tags_to_dense_vector(tag_scores):
    """Convierte [(tagId, relevance)] a DenseVector de 50 dims"""
    vector = np.zeros(50, dtype=float)
    if tag_scores:
        for tag_id, relevance in tag_scores:
            if tag_id in tag_idx_map_bc.value:
                idx = tag_idx_map_bc.value[tag_id]
                vector[idx] = relevance
    return Vectors.dense(vector.tolist())
```

**Uso de Broadcast Variables**:
- `genre_to_idx_bc`: Diccionario de 19 g√©neros ‚Üí evita shuffle
- `tag_idx_map_bc`: Diccionario de 50 tags ‚Üí distribuido a executors

---

## ‚úÖ Verificaci√≥n

### Script de Validaci√≥n
**Archivo**: `movies/src/features/verify_features.py` (87 l√≠neas)

**Checks realizados**:
```bash
‚úÖ Total pel√≠culas: 27,278
‚úÖ Promedio g√©neros: 1.99
‚úÖ Promedio tags: 10.74
‚úÖ Avg tag relevance: 0.188
‚úÖ Pel√≠culas sin tags: 16,897 (62%)
‚úÖ 0 nulos en movieId, genres_vec, tags_vec
‚úÖ Dimensions: genres(19) + tags(50) = 69 total
```

### Outputs de Verificaci√≥n
```
üìä Estad√≠sticas de Features:
  Total pel√≠culas: 27,278
  Promedio g√©neros por pel√≠cula: 1.99
  Promedio tags por pel√≠cula: 10.74
  Promedio tag relevance: 0.188

üìà Distribuci√≥n de Tags:
  n_tags | count
  -------|-------
     0   | 16,897
     1   |    82
   ...   |   ...
    50   |     2

üèÜ Top pel√≠culas con m√°s tags:
  1. Slumdog Millionaire (2008): 50 tags, 0.638 relevance
  2. Life Itself (2014): 50 tags, 0.660 relevance
  3. The Prestige (2006): 49 tags, 0.693 relevance

üìö Metadatos guardados:
  - genres_metadata: 19 g√©neros indexados
  - tags_metadata: top-50 tags con avg_relevance
```

---

## üîÑ Comandos de Ejecuci√≥n

### Generaci√≥n de Features
```bash
cd /home/abraham/Escritorio/PGVD/Recomendacion-Gran-Escala
./scripts/recsys-utils.sh spark-submit movies/src/features/build_features.py
```

**Tiempo de ejecuci√≥n**: ~3-5 minutos
**Recursos**: 2 cores, 2GB memoria por executor

### Verificaci√≥n de Features
```bash
./scripts/recsys-utils.sh spark-submit movies/src/features/verify_features.py
```

**Tiempo de ejecuci√≥n**: ~30 segundos

### Inspecci√≥n en HDFS
```bash
# Listar archivos generados
docker exec namenode hdfs dfs -ls /data/content_features/

# Verificar tama√±os
docker exec namenode hdfs dfs -du -h /data/content_features/

# Ver sample de features
docker exec namenode hdfs dfs -cat /data/content_features/movies_features/*.parquet | head -20
```

---

## üìà Impacto en el Sistema

### Uso en Fases Posteriores

**Fase 5 - Modelo ALS H√≠brido**:
- Incorporar `genres_vec` + `tags_vec` como side information
- Combinar user/item factors de ALS con content features
- Resolver cold-start problem para pel√≠culas nuevas sin ratings

**Fase 6 - Content-Based Filtering**:
- Calcular similaridad coseno entre vectores de pel√≠culas
- Recomendar pel√≠culas similares basadas en contenido
- Complementar CF cuando no hay suficientes ratings

**Fase 7 - Sistema H√≠brido**:
- Ponderaci√≥n din√°mica: `score = Œ±¬∑CF_score + Œ≤¬∑content_score`
- Ajustar Œ±, Œ≤ seg√∫n disponibilidad de ratings del usuario
- Nuevo usuario ‚Üí Œ≤ alto (content-based)
- Usuario activo ‚Üí Œ± alto (collaborative)

### Ventajas del Feature Engineering

‚úÖ **Dimensionalidad controlada**: 69 features vs 1,128 tags originales
‚úÖ **Interpretabilidad**: G√©neros expl√≠citos + tags sem√°nticos
‚úÖ **Eficiencia computacional**: Sparse vectors para g√©neros
‚úÖ **Calidad de tags**: Solo top-50 tags m√°s relevantes (avg >= 0.45)
‚úÖ **Cold-start mitigation**: Pel√≠culas nuevas tienen features aunque no tengan ratings
‚úÖ **Escalabilidad**: Vectores densos/sparse optimizados para MLlib

---

## üöÄ Pr√≥ximos Pasos

### Fase 5: Entrenamiento Modelo ALS
- Cargar ratings.parquet particionados
- Split train/test (80/20) respetando temporalidad
- Entrenar ALS con hyperpar√°metros:
  - `rank=50` (factors latentes)
  - `maxIter=10`
  - `regParam=0.1`
- Evaluar con RMSE, MAE, Precision@K, Recall@K
- Guardar modelo en `/models/als/`

### Mejoras Potenciales
- **Feature expansion**: A√±adir TF-IDF de tags textuales
- **Embeddings**: Word2Vec de g√©neros/tags para capturar similitud sem√°ntica
- **Temporal features**: A√±o de release, tendencias por √©poca
- **Metadata externa**: Box office, duraci√≥n, director/actores

---

## üìö Archivos Generados

```
/home/abraham/Escritorio/PGVD/Recomendacion-Gran-Escala/
‚îú‚îÄ‚îÄ movies/src/features/
‚îÇ   ‚îú‚îÄ‚îÄ build_features.py          580 l√≠neas - Pipeline completo
‚îÇ   ‚îî‚îÄ‚îÄ verify_features.py          87 l√≠neas - Validaci√≥n
‚îú‚îÄ‚îÄ requirements.txt                Dependencias numpy, pandas
‚îî‚îÄ‚îÄ docs/
    ‚îî‚îÄ‚îÄ FASE4_RESUMEN.md            Este documento
```

---

**Documentado**: 29 de octubre de 2025  
**Autor**: Sistema de Recomendaci√≥n MovieLens 20M  
**Siguiente fase**: Entrenamiento modelo ALS (Collaborative Filtering)
